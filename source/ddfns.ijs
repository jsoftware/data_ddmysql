NB. ddfns

NB. =========================================================
NB. main ODBC verbs
NB. words marked with --> have an external interface all
NB. other words are confined to the ODBC utility locale.

NB. =========================================================
errret=: 3 : 0

NB. (errret) error return.  Sets the last error message(s).  Some
NB. errors are generated by the (jdd) verbs (ISInn errors) all others
NB. boil up from the depths of ODBC.
NB.
NB. monad:  errret ilTypeHandle  NB. handle type and handle with last error
NB.         errret clErrmsg      NB. ISI error message text
NB.
NB.  errret ISI03
NB.  errret 0, ch
NB.  errret 1, stmt

LERR=: ''
ALLDM=: i. 0 0
r=. SQL_ERROR
if. iscl y do.
  LERR=: y
else.
  assert. isiu y
  assert. 1 = #@$y
  assert. 2 = #y
  'ht h'=. y
  if. _1=h do.
    LERR=: '.....     0 [MYSQL Driver] No error message'
  else.
    if. 0=ht do.
      s=. mysql_errno h
      if. 0~: p=. mysql_error h do.
        erm=. memr p, 0 _1
      else.
        erm=. 'No error message'
      end.
      if. 0~: p=. mysql_sqlstate h do.
        ers=. memr p, 0 _1
      else.
        ers=. '.....'
      end.
    else.
      s=. mysql_stmt_errno h
      if. 0~: p=. mysql_stmt_error h do.
        erm=. memr p, 0 _1
      else.
        erm=. 'No error message'
      end.
      if. 0~: p=. mysql_stmt_sqlstate h do.
        ers=. memr p, 0 _1
      else.
        ers=. '.....'
      end.
    end.
    LERR=: ers,' ',(5":s),' [MYSQL Driver] ',erm
  end.
end.
if. UseErrRet do.
  r;LERR
else.
  r
end.
)


NB. =========================================================
NB. (clr) clear errors
clr=: 3 : 0
LERR=: ''
ALLDM=: i. 0 0
)

NB. =========================================================
freestmt=: 3 : 0

NB. (freestmt) frees allocated statement handles.
NB.
NB. monad:  freestmt iaSh

erasebind y

NB. also free meta resultset
if. #rs=. 1{"1 SMPALL#~y=0{"1 SMPALL do. mysql_free_result"0 rs end.
SMPALL=: SMPALL#~y~:0{"1 SMPALL

NB. free store result
mysql_stmt_free_result y
mysql_stmt_close y
)


NB. =========================================================
erasebind=: 3 : 0
if. 0= nc <('BIND',":y) do.
  assert. 0= nc <('BINDN',":y)
  n=. ('BINDN',":y)~
  4!:55 <'BINDN',":y
  bind=. ('BIND',":y)~
  4!:55 <'BIND',":y
  assert. 0= nc <('BINDIO',":y)
  io=. ('BINDIO',":y)~
  4!:55 <'BINDIO',":y
  4!:55 <'BINDRR',":y
  for_i. i.n do.
    4!:55 <'BIND',(":y),'_',":i
    4!:55 <'BINDP',(":y),'_',":i
    4!:55 <'BINDLN',(":y),'_',":i
    if. p=. bind + i*SZ_MYSQL_BIND do.
NB. MYSQL_BIND_buffer never allocated for input parameter
      if. 1=io do.  NB. output parameter
        memf {. memr p, MYSQL_BIND_buffer, 1 4
      end.
      memf {. memr p, MYSQL_BIND_is_null, 1 4
      memf {. memr p, MYSQL_BIND_length, 1 4
      memf {. memr p, MYSQL_BIND_error, 1 4
    end.
  end.
end.
)


NB. =========================================================
getcolinfo=: 3 : 0"1

NB. return  catalog database table org_table name org_name column-id(1-base) typename coltype length decimals nullable def nativetype nativeflags

fld=. mysql_fetch_field_direct y
assert. 0~:fld
database=. memr (memr fld, MYSQL_FIELD_db, 1 4), 0, (_2&ic memr fld, MYSQL_FIELD_db_length, 4)
catalog=. memr (memr fld, MYSQL_FIELD_catalog, 1 4), 0, (_2&ic memr fld, MYSQL_FIELD_catalog_length, 4)
table=. memr (memr fld, MYSQL_FIELD_table, 1 4), 0, (_2&ic memr fld, MYSQL_FIELD_table_length, 4)
org_table=. memr (memr fld, MYSQL_FIELD_org_table, 1 4), 0, (_2&ic memr fld, MYSQL_FIELD_org_table_length, 4)
name=. memr (memr fld, MYSQL_FIELD_name, 1 4), 0, (_2&ic memr fld, MYSQL_FIELD_name_length, 4)
org_name=. memr (memr fld, MYSQL_FIELD_org_name, 1 4), 0, (_2&ic memr fld, MYSQL_FIELD_org_name_length, 4)
def=. memr (memr fld, MYSQL_FIELD_def, 1 4), 0, (_2&ic memr fld, MYSQL_FIELD_def_length, 4)
length=. {. _2&ic memr fld, MYSQL_FIELD_length, 4
max_length=. {. _2&ic memr fld, MYSQL_FIELD_max_length, 4
flags=. {. _2&ic memr fld, MYSQL_FIELD_flags, 4
decimals=. {. _2&ic memr fld, MYSQL_FIELD_decimals, 4
charsetnr=. {. _2&ic memr fld, MYSQL_FIELD_charsetnr, 4
type=. {. _2&ic memr fld, MYSQL_FIELD_type, 4

nullable=. 0= flags 17 b. NOT_NULL_FLAG
binary=. charsetnr=63

select. type
case. MYSQL_TYPE_TINY do. typename=. 'TINY' [ coltype=. SQL_TINYINT
case. MYSQL_TYPE_SHORT do. typename=. 'SHORT' [ coltype=. SQL_SMALLINT
case. MYSQL_TYPE_LONG do. typename=. 'LONG' [ coltype=. SQL_INTEGER
case. MYSQL_TYPE_INT24 do. typename=. 'INT24' [ coltype=. SQL_INTEGER
case. MYSQL_TYPE_LONGLONG do. typename=. 'LONGLONG' [ coltype=. SQL_BIGINT
case. MYSQL_TYPE_DECIMAL do. typename=. 'DECIMAL' [ coltype=. SQL_DECIMAL
case. MYSQL_TYPE_NEWDECIMAL do. typename=. 'NEWDECIMAL' [ coltype=. SQL_DECIMAL
case. MYSQL_TYPE_FLOAT do. typename=. 'FLOAT' [ coltype=. SQL_FLOAT
case. MYSQL_TYPE_DOUBLE do. typename=. 'DOUBLE' [ coltype=. SQL_DOUBLE
case. MYSQL_TYPE_BIT do. typename=. 'BIT' [ coltype=. SQL_BIT
case. MYSQL_TYPE_TIMESTAMP do. typename=. 'TIMESTAMP' [ coltype=. SQL_TYPE_TIMESTAMP
case. MYSQL_TYPE_DATE do. typename=. 'DATE' [ coltype=. SQL_TYPE_DATE
case. MYSQL_TYPE_TIME do. typename=. 'TIME' [ coltype=. SQL_TYPE_TIME
case. MYSQL_TYPE_DATETIME do. typename=. 'DATETIME' [ coltype=. SQL_TYPE_TIMESTAMP
case. MYSQL_TYPE_YEAR do. typename=. 'YEAR' [ coltype=. SQL_TINYINT
case. MYSQL_TYPE_STRING do. typename=. 'STRING' [ coltype=. binary{SQL_CHAR,SQL_BINARY
case. MYSQL_TYPE_VAR_STRING do. typename=. 'VAR_STRING' [ coltype=. binary{SQL_VARCHAR,SQL_VARBINARY
case. MYSQL_TYPE_BLOB do. typename=. 'BLOB' [ coltype=. binary{SQL_LONGVARCHAR,SQL_LONGVARBINARY
case. MYSQL_TYPE_SET do. typename=. 'SET' [ coltype=. 0
case. MYSQL_TYPE_ENUM do. typename=. 'ENUM' [ coltype=. binary{SQL_VARCHAR,SQL_VARBINARY
case. MYSQL_TYPE_GEOMETRY do. typename=. 'GEOMETRY' [ coltype=. 0
case. MYSQL_TYPE_NULL do. typename=. 'NULL' [ coltype=. 0
case. do. assert. 0
end.

z=. ,&.> catalog;database;table;org_table;name;org_name;(>:{:y);typename;coltype;length;decimals;nullable;def;type;flags
)

NB. =========================================================
getallcolinfo=: 3 : 0

NB. (getallcolinfo) returns information about all the
NB. columns in a result set.
NB.
NB. monad:  bt =. getallcolinfo iaSh

rs=. sh_to_mres {.y
assert. _1~:rs
if. n=. mysql_num_fields rs do.
  z=. getcolinfo rs,.i.n
else.
  0 15$<''
end.
)

NB. =========================================================
ddconfig=: 3 : 0  NB.-->

NB. (ddconfig) set driver specific config
NB. returns 0
NB.
NB. monad: ddconfig key;value {;key;value...}
NB.

clr 0
key=. {.keynvalue=. |: _2]\ y
value=. {:keynvalue
for_i. i.#key do.
  select. tolower i{::key
  case. 'errret' do. UseErrRet=: -. 0-: {.i{::value
  case. 'dayno' do. UseDayNo=: -. 0-: {.i{::value
  case. 'unicode' do. UseUnicode=: -. 0-: {.i{::value
  end.
end.
0
)

NB. =========================================================
dddriver=: 3 : 0  NB.-->

NB. (dddriver) query driver of current jdd...
NB. returns 0
NB.
NB. monad: bt =. dddriver uuIgnore
NB.
NB.   dddriver ''  NB. current jdd... driver

clr 0
'MYSQL'
)

NB. =========================================================
dddrv=: 3 : 0  NB.-->

NB. (dddrv) lists all ODBC drivers.
NB. returns boxed table of driver names and driver types.
NB.
NB. monad: bt =. ddsrc uuIgnore
NB.
NB.   dddrv ''  NB. boxed table of drivers

clr 0
ret_DD_OK ,:'MySQL';'MySQL'
)

NB. =========================================================
ddsrc=: 3 : 0  NB.-->

NB. (ddsrc) lists all databases in server. Result
NB. is a boxed table of database names and driver types.
NB.
NB. monad: bt =. ddsrc iaCh
NB.
NB.   ddsrc ch  NB. boxed table of data sources

clr 0
if. -. isia y do. errret ISI08 return. end.
if. -. y e. CHALL do. errret ISI03 return. end.

if. _1= sh=. 0{:: rc=. 'show databases' preparesel y do. 1{::rc return. end.
CSPALL=: CSPALL,y,sh
if. sqlresok dat=. ddfet sh,_1 do.
  ddend^:UseErrRet sh
  ret_DD_OK dat,.(#dat)#<'MySQL'
else.
  dat [ ddend sh
end.
)


NB. =========================================================
ddtbl=: 3 : 0  NB.-->

NB. (ddtbl) lists all the tables in the data source with
NB. connection handle (y). The result is a statement handle.
NB.
NB. NIMP? maybe more useful to return the table list and behave
NB. like (ddsrc) and (ddcol) (see ddtblx)
NB.
NB. monad:  iaSh =. ddtbl iaCh
NB.
NB.  ch =. ddcon 'dsn=jaccess'
NB.  sh =. ddtbl ch
NB.  ddfet sh,_1      NB. boxed list of tables

NB. test argument
clr 0
if. -. isia y do. errret ISI08 return. end.
if. -. y e. CHALL do. errret ISI03 return. end.

if. _1= sh=. 0{:: rc=. 'show tables' preparesel y do. rc return. end.
NB. update connection/statement pairs & return statement handle
CSPALL=: CSPALL,y,sh
ret_DD_OK sh
)

NB. =========================================================
ddtblx=: 3 : 0  NB.-->

NB. (ddtblx) like (ddtbl) except table information is immediately
NB. returned in a more readable format.
NB.
NB. monad:  ddtblx iaCh

if. -.@sqlresok z=. ddtbl y do. z
elseif. -.@sqlresok dat=. ddfch sh,_1 [ sh=. sqlres z do. dat
elseif.do. fmtfchres dat [ ddend^:UseErrRet sh
end.
)

NB. =========================================================
NB. ddcheck  NB.-->
ddcheck=: 3 : 0
if. _1=y do. empty smoutput dderr $0 else. y end.
)
NB. =========================================================
NB. COMPATIBLE (ddcol) simply returns a header with no
NB. error when given a column that doesn't exist in a valid table.
NB. This is also what the original 14!:4 does.  Returning
NB. an error would make more sense.

ddcol=: 4 : 0  NB. -->

NB. (ddcol) lists all the columns in table (x).
NB.
NB. dyad:  bt =. clTable ddcol iaCh
NB.
NB.  ch =. ddcon 'dsn=jaccess'
NB.  'tdata' ddcol ch

NB. test arguments
clr 0
w=. y
if. -. (iscl x) *. isia w=. fat w do. errret ISI08 return. end.
if. -. w e. CHALL do. errret ISI03 return. end.
x=. utf8 ,x

sql=. 'select * from ', x,' where 1=0'
if. _1= sh=. 0{:: rc=. sql preparesel w do. 1{::rc return. end.
ci=. getallcolinfo sh
freestmt sh

NB. TABLE_CAT
NB. TABLE_SCHEM  db
NB. TABLE_NAME   tb
NB. COLUMN_NAME  column
NB. DATA_TYPE
NB. TYPE_NAME     datatype
NB. COLUMN_SIZE
NB. BUFFER_LENGTH
NB. DECIMAL_DIGITS
NB. NUM_PREC_RADIX
NB. NULLABLE       -.notnull
NB. REMARKS
NB. COLUMN_DEF
NB. SQL_DATA_TYPE
NB. SQL_DATETIME_SUB
NB. CHAR_OCTET_LENGTH
NB. ORDINAL_POSITION
NB. IS_NULLABLE       notnull{::'YES';'NO'

hdr=. <;._1 ' TABLE_CAT TABLE_SCHEM TABLE_NAME COLUMN_NAME DATA_TYPE TYPE_NAME COLUMN_SIZE BUFFER_LENGTH DECIMAL_DIGITS NUM_PREC_RADIX NULLABLE REMARKS COLUMN_DEF SQL_DATA_TYPE SQL_DATETIME_SUB CHAR_OCTET_LENGTH ORDINAL_POSITION IS_NULLABLE'
r=. 0 0$<''
if. #ci do.
NB.  catalog database table org_table name org_name column-id(1-base) typename coltype length decimals nullable def nativetype nativeflags
  cat=. 0{"1 ci
  db=. 1{"1 ci
  tb=. 2{"1 ci
  column=. 4{"1 ci
  ordid=. 6{"1 ci
  type_name=. 7{"1 ci
  data_type=. 8{"1 ci
  col_size=. 9{"1 ci
  decimals=. 10{"1 ci
  nullable=. 11{"1 ci
  dflt=. 12{"1 ci

  radix=. <"1 <. 10 * (>data_type) e. SQL_TINYINT, SQL_SMALLINT, SQL_INTEGER, SQL_INTEGER, SQL_BIGINT, SQL_DECIMAL, SQL_DECIMAL, SQL_FLOAT, SQL_DOUBLE

  sql_data_type=. data_type
  sub=. <"1[ 4|1+(SQL_TYPE_DATE,SQL_TYPE_TIME,SQL_TYPE_TIMESTAMP) i. >data_type
  char_octlen=. <"1 <. (>col_size) * (>data_type) e. SQL_CHAR, SQL_BINARY, SQL_VARCHAR, SQL_VARBINARY, SQL_LONGVARCHAR, SQL_LONGVARBINARY

  s0=. (>col_size) * (>data_type) e. SQL_BINARY, SQL_CHAR, SQL_LONGVARBINARY, SQL_LONGVARCHAR, SQL_VARBINARY, SQL_VARCHAR
  s1=. 8 1 8 8 4 4 2 1 10 12 23 0 {~ (>data_type) i.~ SQL_BIGINT, SQL_BIT, SQL_DECIMAL, SQL_DOUBLE, SQL_FLOAT, SQL_INTEGER, SQL_SMALLINT, SQL_TINYINT, SQL_TYPE_DATE, SQL_TYPE_TIME, SQL_TYPE_TIMESTAMP
  buflen=. <"1 <. s0 + s1

NB. SQL_BIGINT, SQL_BINARY, SQL_BIT, SQL_CHAR, SQL_DECIMAL, SQL_DOUBLE, SQL_FLOAT, SQL_INTEGER, SQL_LONGVARBINARY, SQL_LONGVARCHAR, SQL_SMALLINT, SQL_TINYINT, SQL_TYPE_DATE, SQL_TYPE_TIME, SQL_TYPE_TIMESTAMP, SQL_VARBINARY, SQL_VARCHAR

  r=. cat,.db,.tb,.column,.data_type,.type_name,.col_size,.buflen,.((#ci)#<,0),.radix,.nullable,.((#ci)#<''),.dflt,.sql_data_type,.sub,.char_octlen,.ordid,.((>nullable){'NO';'YES')
end.
if. #r do.
  r=. hdr,r
else.
  r=. ,:hdr
end.
ret_DD_OK r
)

NB. =========================================================
ddcon=: 3 : 0  NB.-->

NB. (ddcon) connects to an ODBC data source and returns a connection handle.
NB. The (y) argument is an ODBC connection string.
NB.
NB. monad:  iaCh =. ddcon clCstr
NB.
NB.   ddcon 'dsn=jdata'

f=. (i.&';')({. ; }.@}.) ]

NB. test arguments:
clr 0
if. -.iscl y do. errret ISI08 return. end.
y=. utf8 ,y

NB. ddcon 'Server=127.0.0.1;Database=jdata;usr=root;pwd=****'
keypair=. <;._2 y,(';'~:{:y)#';'
keyname=. tolower@dltb@({.~ i.&'=')&.> keypair
keyvalue=. dltb@(}.~ >:@(i.&'='))&.> keypair
if. keyname e.~ <'server' do.
  server=. > keyvalue {~ keyname i. <'server'
else.
  server=. 'localhost'
end.
if. keyname e.~ <'port' do.
  port=. 0". > keyvalue {~ keyname i. <'port'
else.
  port=. 0
end.
if. keyname e.~ <'database' do.
  database=. > keyvalue {~ keyname i. <'database'
else.
  database=. <0
end.
if. keyname e.~ <'uid' do.
  uid=. > keyvalue {~ keyname i. <'uid'
else.
  uid=. ''
end.
if. keyname e.~ <'pwd' do.
  pwd=. > keyvalue {~ keyname i. <'pwd'
else.
  pwd=. ''
end.

if. 0= handle=. mysql_init ::0: 0 do.
  errret ISI16 return.
end.
if. 0-: mysql_real_connect handle;server;uid;pwd;database;port;(<0);0 do.
  r=. errret 0,handle
  r [ mysql_close handle return.
end.
mysql_autocommit handle,1
mysql_set_character_set handle;'utf8'
HDBC=: handle

CHALL=: CHALL,HDBC
dddbms HDBC
ret_DD_OK HDBC
)


NB. =========================================================
dddis=: 3 : 0"0   NB.-->

NB. (dddis) disconnects data sources.
NB.
NB. monad:  dddis i[0,1]Ch
NB.
NB.  dddis ch      NB. one handle
NB.  dddis CHALL   NB. all handles

clr 0
w=. y
if. -.isia w=. fat w do. errret ISI08 return. end.
if. -. w e. CHALL do. errret ISI03 return. end.

if. #sh=. 1{"1 CSPALL#~w=0{"1 CSPALL do. ddend"0 sh end.
ch=. w NB. save in case dll call modifies value

NB. attempt to disconnect
if. sqlbad mysql_close w do. errret 0,ch return. end.

NB. remove handles from globals
CHALL=: CHALL-.ch
CSPALL=: CSPALL#~ch~:0{"1 CSPALL
DBMSALL=: DBMSALL#~ch~:>0{("1) DBMSALL
ret_DD_OK DD_OK
)

NB. =========================================================
NB. prepare statement for query that return result set
preparesel=: 4 : 0
sql=. ,utf8 x
if. 0= sh=. mysql_stmt_init y do.
  _1;ISI17 return.
end.
if. 0~: 1&(17 b.)^:IFWIN mysql_stmt_attr_set sh; STMT_ATTR_CURSOR_TYPE; ,CURSOR_TYPE_READ_ONLY do.
  r=. errret 1,sh
  mysql_stmt_close sh
  _1 ,&< r return.
end.
if. 0~: 1&(17 b.)^:IFWIN mysql_stmt_attr_set sh; STMT_ATTR_PREFETCH_ROWS; ,PREFETCH_ROWS do.
  r=. errret 1,sh
  mysql_stmt_close sh
  _1 ,&< r return.
end.
if. 0~: rc=. mysql_stmt_prepare sh;sql;#sql do.
  r=. errret 1,sh
  mysql_stmt_close sh
  _1 ,&< r return.
end.
if. 0~: mysql_stmt_param_count sh do.
  mysql_stmt_close sh
  _1 ,&< errret ISI56 return.
end.
if. 0= mres=. mysql_stmt_result_metadata sh do.
  r=. errret 1,sh
  mysql_stmt_close sh
  mysql_stmt_close sh
  _1 ,&< r return.
end.
if. 0= mysql_num_fields mres do.
  mysql_free_result mres
  mysql_stmt_close sh
  _1 ,&< errret ISI53
end.
SMPALL=: SMPALL,sh,mres
sh;''
)


NB. =========================================================
NB. prepare statement for query that does not return result set
preparesql=: 4 : 0
sql=. ,utf8 x
if. 0= sh=. mysql_stmt_init y do.
  _1;ISI17 return.
end.
if. 0~: rc=. mysql_stmt_prepare sh;sql;#sql do.
  r=. errret 1,sh
  mysql_stmt_close sh
  _1 ,&< r return.
end.
sh;''
)


NB. =========================================================
ddsel=: 4 : 0  NB.-->

NB. (ddsel) selects data. (y) argument is a connection handle and
NB. (x) is an SQL statement that generates a result set.
NB.
NB. dyad:  iaCh =. clSql ddsel iaCh
NB.
NB.   'select * from tdata' ddsel ch
NB.
NB.   NB. can be used to call stored procedures that
NB.   NB. take simple arguments and return result sets
NB.   NB. driver must support escape {}'s and stored procs
NB.   '{call procname(''chararg'')}' ddsel ch

NB. test arguments
clr 0
if. -.(isia w=. fat y) *. iscl x do. errret ISI08 return. end.
if. -.w e. CHALL do. errret ISI03 return. end.
x=. utf8 ,x

if. IFUNIX do.
  x1=. mema >:+:#x
  try.
    n=. mysql_real_escape_string y;x;(<x1);#x
    x=. memr x1,0,n
  catch. end.
  memf x1
end.

if. _1= sh=. 0{:: rc=. x preparesel w do. 1{::rc return. end.

CSPALL=: CSPALL,w,sh
ret_DD_OK sh
)

NB. =========================================================
NB. start or end transaction. CHTR not updated here
transact=: 4 : 0
assert. x e. SQL_COMMIT,SQL_ROLLBACK,SQL_BEGIN
COMRBK=. x{::'COMMIT';'ROLLBACK';'START TRANSACTION'
if. MYSQL_OK= r=. mysql_real_query y;COMRBK;(#COMRBK) do.
  DD_OK
else.
  SQL_ERROR
end.
)


NB. =========================================================
ddsql=: 4 : 0  NB.-->

NB. (ddsql) executes SQL statements (y) argument is a connection handle and
NB. (x) is any SQL statement.  Sets rows changed/modified for (ddcnt).
NB.
NB. dyad:  iaCh =. clSql ddsql iaCh
NB.
NB.   'delete from tdata' ddsel ch

NB. test arguments
clr DDROWCNT=: 0
if. -.(isia y) *. iscl x do. errret ISI08 return. end.
if. -.y e.CHALL do. errret ISI03 return. end.
x=. utf8 ,x
x1=. mema >:+:#x
try.
  n=. mysql_real_escape_string y;x;(<x1);#x
  x=. memr x1,0,n
catch. end.
memf x1

if. MYSQL_OK ~: rc=. mysql_real_query y;x;#x do. errret 0,y return. end.

NB. set number of rows affected for (ddcnt)
DDROWCNT=: mysql_affected_rows y

ret_DD_OK DD_OK
)


NB. =========================================================
ddfch=: 3 : 0  NB.-->

NB. ddfch
NB. The dyad is an extension of the original jodbc ddfch verb.
NB. if (x) is _2, data will be returned in raw format, otherwise
NB. data returned in jodbc compatible format.
NB. The original jodbc usage (COLUMNBUF) is ignored.
NB.
NB. monad:  blut =. ddfch ilShRows
NB.
NB.   sh=. 'select this,and,that from sometable' ddsel ch
NB.   ddfch sh     NB. one row
NB.   ddfch sh,10  NB. next 10 rows
NB.   ddfch sh,_1  NB. all remaining rows
NB.
NB. dyad:  blut =. iaBuffhint ddfch ilShRows
NB.
NB.   sh =. 'select these,here,integers from reallybigtable' ddsel ch
NB.
NB.   NB. get 1e5 rows with each fetch operation until all data is returned
NB.   100000 ddfch sh,_1

1 ddfch y
:
clr 0
if. -. isiu y do. errret ISI08 return. end.
'sh r'=. 2{.,y,1
if. -. sh e.1{"1 CSPALL do. errret ISI04 return. end.
r=. (r<0){r,_1  NB. tolerate negs other than _1
if. 0=#ci=. getallcolinfo sh do.
  r=. errret 1,sh
  r [ freestmt sh return.
else.
  z=. ci getdata sh,r
  if. UseErrRet do.
    if. (<<<0)-:{.z do.
      r=. fmtfch&.>^:(_2~:x) }.z
      ret_DD_OK r
    else.
      z
    end.
  else.
    r=. fmtfch&.>^:(_2~:x) z
  end.
end.
)


NB. =========================================================
ddfet=: 3 : 0  NB.-->

NB. (ddfet) fetchs data by rows.  This verb must be used
NB. for long character and binary types.  For fixed length
NB. and short types (ddfch) is much faster.  The ODBC SQLGetData
NB. function is not well suited for J use because it forces you to loop.
NB. You must loop for each row and you must loop within each long
NB. column to collect large data objects.  When fetching data it's best
NB. to use (ddfch) on columns it can collect reserving (ddfet)
NB. only for those values that (ddfch) cannot fetch.
NB.
NB. monad:  ddfet ilShRows
NB.
NB.   ch=. ddcon 'dsn=mydatabase'
NB.   sh=. 'select bigbinary from mytable where myprimarykey = 666' ddsel ch
NB.   data =. ddfet sh

clr 0
if. -. isiu y do. errret ISI08 return. end.
if. -. isiu y do. errret ISI08 return. end.
'sh r'=. 2{.,y,1
if. -. sh e.1{"1 CSPALL do. errret ISI04 return. end.
r=. (r<0){r,_1  NB. tolerate negs other than _1
if. 0=#ci=. getallcolinfo sh do.
  r=. errret 1,sh
  r [ freestmt sh return.
else.
  z=. ci getdata sh,r
  if. UseErrRet do.
    if. (<<<0)-:{.z do.
      r=. }.z
      if. #>{.r do.
        r=. |:@:(((<@,"_1)^:(0=L.))@>) r
      else.
        r=. (0,#r)$<''
      end.
      ret_DD_OK r
    else.
      z
    end.
  else.
    if. -. SQL_ERROR-: z do.
      r=. z
      if. #>{.r do.
        r=. |:@:(((<@,"_1)^:(0=L.))@>) r
      else.
        r=. (0,#r)$<''
      end.
    else.
      z
    end.
  end.
end.
)


NB. =========================================================
ddcnt=: 3 : 0  NB.-->

NB. (ddcnt) returns number of rows affected by last (ddsql) command.
NB.
NB. monad:  ddcnt uuIgnore

ret_DD_OK DDROWCNT
)


NB. =========================================================
ddend=: 3 : 0"0  NB.-->

NB. (ddend) ends statements and frees statement handles.
NB. Bound nouns are also erased.
NB.
NB. monad:  ddend i[0,1]Sh

clr 0
w=. y
if. -.isia w=. fat w do. errret ISI08 return. end.
if. -.w e.1{"1 CSPALL do. errret ISI04 return. end.
sh=. w

NB. free and clean up regardless of sql errors
z=. freestmt sh
CSPALL=: CSPALL#~sh~:1{"1 CSPALL

NB. now check for errors
if. sqlbad z do. errret 1,sh else. ret_DD_OK DD_OK end.
)

NB. =========================================================
dddata=: 3 : 0  NB.-->

NB. (dddata) gets data bound to single column for a stmt handle.
NB.
NB. monad:  dddata ilShCol

NB. check argument
clr 0
w=. >{.y
if. -. isia w=. fat w do. errret ISI08 return. end.
if. -.w e.1{"1 CSPALL do. errret ISI04 return. end.
c=. >{:y
if. -. isia c=. fat c do. errret ISI08 return. end.
if. (0>c) +. c>: ('BINDN',":w)~ do. errret ISI54 return. end.

ret_DD_OK ". ::(''"_) 'BIND',(":w),'_',":c
)

NB. =========================================================
dddataln=: 3 : 0

NB. (dddata) gets data length bound to single column for a stmt handle.
NB.
NB. monad:  dddata ilShCol
NB. internal use

NB. check argument
clr 0
w=. >{.y
if. -. isia w=. fat w do. errret ISI08 return. end.
if. -.w e.1{"1 CSPALL do. errret ISI04 return. end.
c=. >{:y
if. -. isia c=. fat c do. errret ISI08 return. end.
if. (0>c) +. c>: ('BINDN',":w)~ do. errret ISI54 return. end.

". ::(''"_) 'BINDLN',(":w),'_',":c
)


NB. =========================================================
dddcnt=: 3 : 0  NB.-->

NB. (dddcnt) actual number of rows in last fetch.
NB.
NB. monad:  dddcnt iaSh

NB. check argument
clr 0
w=. y
if. -. isia w=. fat w do. errret ISI08 return. end.
if. -.w e.1{"1 CSPALL do. errret ISI04 return. end.

ret_DD_OK ". ::0: 'BINDRR',":w
)

NB. =========================================================
ddrow=: dddcnt NB. not sure which name to use...

initodbcenv=: 3 : 0

NB. (initodbcenv) first time initialization of ODBC environment.
NB.
NB. monad: initodbcenv uuIgnore

NB. intial values
CHTR=: CHALL=: i.0  NB. all connection handles (pending transactions)
CSPALL=: 0 2$0      NB. all statement handles (connection,statement pairs)
SMPALL=: 0 2$0      NB. all metaresultset handles (statement,metaresultset pairs)
DBMSALL=: 0 12$<''  NB. properties of connection handles
LERR=: ''           NB. last error message
ALLDM=: i. 0 3      NB. all last diagnostic messages
BADTYPES=: i. 0 0   NB. table of unbindable/ungetable columns
DDROWCNT=: 0        NB. number of rows affected by last (ddsql) command

DD_OK
)


NB. =========================================================
endodbcenv=: 3 : 0

NB.  (endodbcenv) frees all statement, connection and environment handles.
NB.
NB.  QUESTION? is all this necessary - you would think just freeing the
NB.  environment would automatically clean up.
NB.
NB.  monad:  iaRc =. endodbcenv uuIgnore

set=. 0&= @: (4!:0)
if. set <'CHTR' do. if. #CHTR do. ddrbk CHTR end. end.
if. set <'CSPALL' do. if. #CSPALL do. ddend {:"1 CSPALL end. end.
if. set <'CHALL' do. if. #CHALL do. dddis CHALL end. end.
erase ;:'CSPALL CHALL CHTR'
)


NB. =========================================================
ddcnm=: 3 : 0  NB.-->

NB. (ddcnm) returns a boxed list of column names in
NB. statement result sets.
NB.
NB. monad:  blcl =. ddcnm iaSh
NB.
NB.  sh=. 'select * from whatever' ddsel ch
NB.  ddcnm sh


NB. check argument
clr 0
w=. y
if. -. isia w=. fat w do. errret ISI08 return. end.
if. -.w e.1{"1 CSPALL do. errret ISI04 return. end.

NB. get column information and return names
if. 0=#ci=. getallcolinfo w do. errret 0,sh_to_ch w return. end.
assert. 15= {:@$ ci
ret_DD_OK 4{"1 ci
)


NB. =========================================================
NB. COMPATIBLE? dderr accepts only empty arguments this verb
NB. accepts and ignores any argument.

dderr=: 3 : 0  NB.-->

NB. (dderr) returns the last error message (if any).  Optional
NB. (x) code displays additional error and diagnostic information.
NB.
NB. monad:  dderr uuIgnore
NB. dyad:   iaMore dderr uuIgnore

0 dderr y
:
LERR
)


NB. =========================================================
ddtrn=: 3 : 0  NB.-->

NB. (ddtrn) begins a transaction on connection handle (y)
NB.
NB. monad:  ddtrn iaCh

NB. test argument
clr 0
w=. fat y
if. -. isia w=. fat w do. errret ISI08 return. end.
if. -. w e. CHALL do. errret ISI03 return. end.
if. w e. CHTR do. errret ISI07 return. end.
NB. nested transaction not allowed in ODBC
NB. set the handle to manual commit mode
if. sqlok SQL_BEGIN transact w do.
  CHTR=: ~.CHTR,y
  ret_DD_OK DD_OK
else.
  errret 0,w
end.
)


NB. =========================================================
comrbk=: 4 : 0

NB. (comrbk) commits or rolls back transactions on connection handle (y)
NB.
NB. dyad:  iaType comrbk iaCh
NB.
NB.  SQL_COMMIT comrbk ch

NB. test argument
clr 0
w=. y
if. -. isia w=. fat w do. errret ISI08 return. end.
if. -. w e. CHALL do. errret ISI03 return. end.
if. -. w e. CHTR do. errret ISI07 return. end.

NB. commit transaction
if. sqlok x transact w do.
  CHTR=: CHTR-.y
  ret_DD_OK DD_OK
else.
  errret 0,w
end.
)


NB. =========================================================
ddcom=: 3 : 0  NB.-->
SQL_COMMIT comrbk y
)


NB. =========================================================
ddrbk=: 3 : 0  NB.-->
SQL_ROLLBACK comrbk y
)

NB. =========================================================
ddttrn=: 3 : 0"0  NB.-->

NB. y is ch
NB. return 1 if inside transaction, otherwise (include  error conditions) return 0
NB. if y is _1, test for all ch

if. _1~: y do.
  if. y e. CHALL do.
    y e. CHTR
  else.
    0
  end.
else.
  0~:#CHTR
end.
)


NB. =========================================================
dddbms=: 3 : 0  NB.-->

NB. dddbms ch
NB. return datadriver;dsn;uid;server;name;ver;drvname;drvver;charset;chardiv;bugflag

if. -. isia y=. fat y do. errret ISI08 return. end.
if. -.y e. CHALL do. errret ISI03 return. end.
ch=. y
clr 0
if. ch e. >0{("1) DBMSALL do.
  ret_DD_OK }.DBMSALL{~(>0{("1) DBMSALL)i.ch
  return.
end.
bugflag=. 0
chardiv=. 1  NB. some odbc driver need to divide column size to get the true column size in unicode characters
if. 'utf8' -: 4{. memr 0 _1,~ mysql_character_set_name ch do.
  charset=. UTF8
  chardiv=. 3
else.
  charset=. OEMCP
end.
dsn=. ''
uid=. ''
server=. memr 0 _1,~ mysql_get_host_info ch
ver=. memr 0 _1,~ mysql_get_server_info ch
drvname=. libmysql
drvver=. memr 0 _1,~ mysql_get_client_info''
name=. 'MYSQL'

DBMSALL=: DBMSALL, y; r=. 'MYSQL';dsn;uid;server;name;ver;drvname;drvver;charset;chardiv;bugflag
ret_DD_OK r
)

NB. =========================================================
NB. not implemented

ddbind=: ddfetch=: ddbtype=: errret bind ISI14
